# 演禽术项目 - 组件化细要

本方案旨在通过 UI 组件化与数据逻辑组件化，提升项目的可扩展性，确保核心排盘逻辑与 UI 表现的一致性。



## 二、 数据组件化：万年历管理器 (CalendarManager)

### 1. 设计初衷
万年历数据量大（1900-2060年），且按年代分散在多个 JSON 文件中。组件化可以将文件索引、异步加载、解析、内存缓存等复杂逻辑完全隐藏。

### 2. 技术规格
- **文件路径**：`entry/src/main/ets/utils/CalendarManager.ets`
- **核心模式**：单例模式 (Singleton)。
- **核心接口**：`getDayInfo(year, month, day)`。
- **加载逻辑**：
  - 自动根据年份映射文件名（如 2024 -> `calendar_data_0013.json`）。
  - 使用 `Map<string, Array<CalendarDayInfo>>` 实现年代数据的内存缓存。

### 3. 优势
- **性能**：避免在页面切换或日期微调时重复读取磁盘。
- **解耦**：页面组件不再需要了解 `rawfile` 的具体路径，仅通过 `CalendarManager` 获取标准的 `CalendarDayInfo` 对象。

---





## 三、 组件化引用规范

1. **统一存放**：
   - 逻辑/数据工具存放在 `utils/`。

2. **类型安全**：
   - 所有传递给组件的数据必须通过显式的 `interface` 定义。
   - 禁止使用 `any` 或匿名对象。

3. **初始化流程**：
   - 涉及 Context 的管理器（如 CalendarManager）需在 App 或 Page 的 `aboutToAppear` 中调用 `.init(context)`。

---

## 四、 移植与复用指南

### 1. 项目内复用 (Internal Reuse)
在本项目的新页面中使用组件或工具，遵循以下步骤：

- **第一步：导入 (Import)**
  ```ts
  // 页面顶部导入
  import { CalendarManager } from '../utils/CalendarManager';
  ```
- **第二步：初始化 (如有必要)**
  在 Page 的 `aboutToAppear` 生命周期函数中：
  ```ts
  CalendarManager.getInstance().init(getContext(this));
  ```
- **第三步：调用 (Usage)**
  在 `build()` 中直接使用组件标签。

### 2. 项目间移植 (Cross-Project Migration)
将组件迁移到全新的 HarmonyOS 项目中，需确保“代码 + 资源”同步到位：


- **数据工具迁移 (`CalendarManager`)**：
  1. 拷贝 `entry/src/main/ets/utils/CalendarManager.ets` 到新项目。
  2. **关键：拷贝资源文件**。必须将原项目的 `entry/src/main/resources/rawfile/calendar/` 目录下所有 JSON 文件完整拷贝到新项目的 `rawfile/calendar/` 中。
  3. 检查 `oh-package.json5` 是否已包含 `@kit.AbilityKit` 和 `@kit.ArkTS` 等标准库。

- **移植注意事项**：
  - **路径一致性**：`CalendarManager` 内部硬编码了 `calendar/` 路径，请确保新项目 `rawfile` 下目录名一致。
  - **单例状态**：在跨项目使用时，务必记得在入口处调用 `init()`，否则 `context` 为空会导致读取文件失败。
