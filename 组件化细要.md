# 演禽术项目 - 组件化细要

本方案旨在通过 UI 组件化与数据逻辑组件化，提升项目的可扩展性，确保核心排盘逻辑与 UI 表现的一致性。

---

## 一、UI 组件化：九宫排盘系统

### 1. 设计初衷
九宫排盘涉及复杂的UI展示和交互逻辑，通过组件化拆分可以实现：
- 代码复用：其他页面可直接引入组件
- 职责分离：页面负责状态管理，组件负责展示
- 易于维护：逻辑清晰，修改影响范围可控

### 2. 组件结构

#### DunjiaNineGrid（九宫格显示组件）
- **文件路径**：`entry/src/main/ets/components/DunjiaNineGrid.ets`
- **职责**：
  - 展示九宫格排盘结果（九星、八门、天盘地盘、八神）
  - 显示时间信息（阳历、农历、真太阳时）
  - 显示局数信息和概览
  - 处理宫位点击事件
- **接口定义**：
  ```typescript
  @Prop panResult: DunjiaPanResult | null = null
  @Prop selectedPalace: number | null = null
  onPalaceClick?: (index: number) => void
  ```
- **使用示例**：
  ```typescript
  DunjiaNineGrid({
    panResult: this.panResult,
    selectedPalace: this.selectedPalace,
    onPalaceClick: (index) => {
      this.selectedPalace = index
    }
  })
  ```

#### DunjiaPalaceDetail（宫位详情组件）
- **文件路径**：`entry/src/main/ets/components/DunjiaPalaceDetail.ets`
- **职责**：
  - 显示选中宫位的详细信息
  - 提供九星、八门、八神的详细解释
  - 天盘地盘组合分析（相生相克、伏吟等）
  - 显示特殊标识（值符宫、值使宫、三奇六仪）
  - 筛选并展示相关格局
  - 支持垂直滚动查看完整内容
- **接口定义**：
  ```typescript
  @Prop panResult: DunjiaPanResult | null = null
  @Prop selectedPalace: number | null = null
  ```
- **使用示例**：
  ```typescript
  DunjiaPalaceDetail({
    panResult: this.panResult,
    selectedPalace: this.selectedPalace
  })
  ```

### 3. 页面容器（DunjiaPalacePage）
- **文件路径**：`entry/src/main/ets/pages/DunjiaPalacePage.ets`
- **职责**：
  - 状态管理（@State）
  - 调用排盘引擎
  - 组件组合与布局
  - 处理路由参数
- **核心代码**：
  ```typescript
  @State panResult: DunjiaPanResult | null = null
  @State selectedPalace: number | null = null
  @State loading: boolean = true
  
  // 排盘计算
  private async computePan() {
    const input: DunjiaInput = {
      dateTime: this.currentDateTime,
      longitude: 116.4074,
      sceneType: DunjiaSceneType.GENERAL_STUDY
    }
    this.panResult = await this.engine.computePan(input)
  }
  ```

### 4. 状态传递方案
鸿蒙平台的状态传递使用以下装饰器：
- **@Prop**：单向数据传递（父→子），适用于展示型组件
- **@Link**：双向数据绑定，适用于需要子组件修改父组件状态的场景
- **@ObjectLink + @Observed**：处理复杂对象的响应式更新

**本项目采用方案**：
- 使用 `@Prop` 传递 `DunjiaPanResult` 对象（排盘结果）
- 使用 `@Prop` 传递 `selectedPalace` 状态（选中宫位）
- 使用回调函数 `onPalaceClick` 处理点击事件

### 5. 优势
- **代码量减少**：页面从700+行减少到127行
- **可复用性**：组件可在任何页面中使用
- **可维护性**：职责清晰，修改影响范围可控
- **一致性**：统一的展示逻辑确保UI一致

---

## 二、数据组件化：万年历管理器 (CalendarManager)

### 1. 设计初衷
万年历数据量大（1900-2060年），且按年代分散在多个 JSON 文件中。组件化可以将文件索引、异步加载、解析、内存缓存等复杂逻辑完全隐藏。

### 2. 技术规格
- **文件路径**：`entry/src/main/ets/utils/CalendarManager.ets`
- **核心模式**：单例模式 (Singleton)
- **核心接口**：`getDayInfo(year, month, day)`
- **加载逻辑**：
  - 自动根据年份映射文件名（如 2024 → `calendar_data_0013.json`）
  - 使用 `Map<string, Array<CalendarDayInfo>>` 实现年代数据的内存缓存

### 3. 优势
- **性能**：避免在页面切换或日期微调时重复读取磁盘
- **解耦**：页面组件不再需要了解 `rawfile` 的具体路径，仅通过 `CalendarManager` 获取标准的 `CalendarDayInfo` 对象

---

## 三、数据逻辑组件化：排盘引擎 (DunjiaEngine)

### 1. 设计初衷
奇门遁甲排盘算法复杂，涉及：
- 阴阳遁判断与局数计算
- 值符值使定位
- 九星八门布局
- 三奇六仪排列
- 八神定位
- 格局识别

通过引擎组件化，确保算法的正确性和一致性。

### 2. 技术规格
- **文件路径**：`entry/src/main/ets/utils/DunjiaEngine.ets`
- **核心模式**：单例模式 (Singleton)
- **核心接口**：`async computePan(input: DunjiaInput): Promise<DunjiaPanResult>`
- **输入参数**：
  ```typescript
  interface DunjiaInput {
    dateTime: Date              // 公历时间
    longitude: number           // 地理经度（用于真太阳时）
    sceneType: DunjiaSceneType  // 研习场景类型
  }
  ```
- **输出结果**：
  ```typescript
  interface DunjiaPanResult {
    dunType: DunType            // 阴遁/阳遁
    juLabel: string             // 局数标签
    zhiFuPalace: number         // 值符所在宫
    zhiShiPalace: number        // 值使所在宫
    palaces: PalaceState[]      // 九宫详细状态
    dayInfo: CalendarDayInfo    // 干支信息
    hourGanZhi: string          // 时辰干支
    solarTimeOffset: number     // 真太阳时偏移
    gejuPatterns: GejuPattern[] // 格局列表
  }
  ```

### 3. 核心算法
- **阴阳遁判断**：基于节气（冬至→夏至为阳遁，夏至→冬至为阴遁）
- **局数计算**：根据节气与上中下元
- **值符定位**：根据时干和局数
- **值使定位**：根据时支
- **格局识别**：三奇得使、天遁、地遁、人遁、伏吟、反吟等

### 4. 优势
- **准确性**：算法集中管理，确保一致性
- **可测试性**：独立的引擎便于单元测试
- **可扩展性**：新增格局识别无需修改页面代码

---

## 四、组件化引用规范

### 1. 目录结构
```
entry/src/main/ets/
├── components/           # UI可复用组件
│   ├── DunjiaNineGrid.ets       # 九宫格显示组件
│   └── DunjiaPalaceDetail.ets   # 宫位详情组件
├── pages/               # 页面容器
│   ├── Calendar.ets
│   ├── DunjiaPanel.ets
│   ├── DunjiaPalacePage.ets    # 九宫盘页面
│   └── Index.ets
└── utils/              # 数据与逻辑工具
    ├── CalendarManager.ets     # 万年历管理器
    ├── DunjiaEngine.ets        # 排盘引擎
    └── SolarTimeHelper.ets     # 真太阳时工具
```

### 2. 类型安全要求
- 所有传递给组件的数据必须通过显式的 `interface` 定义
- 禁止使用 `any` 或 `unknown` 类型
- 回调函数必须明确参数类型

**示例**：
```typescript
// ✅ 正确
onPalaceClick?: (index: number) => void

// ❌ 错误
onPalaceClick?: (data: any) => void
```

### 3. 初始化流程
- 涉及 Context 的管理器（如 CalendarManager）需在 App 或 Page 的 `aboutToAppear` 中调用 `.init(context)`
- 单例模式的组件使用 `getInstance()` 获取实例

**示例**：
```typescript
aboutToAppear() {
  // 初始化万年历管理器
  CalendarManager.getInstance().init(getContext(this))
  
  // 获取排盘引擎实例
  this.engine = DunjiaEngine.getInstance()
  
  // 执行排盘
  this.computePan()
}
```

### 4. 状态传递规范
鸿蒙平台状态传递严格管控，必须遵循以下规范：

#### @Prop 装饰器
- 用于单向数据传递（父→子）
- 适用于基本类型和对象
- 子组件不能修改@Prop值

#### @Link 装饰器
- 用于双向数据绑定
- 父组件使用 `$` 传递引用：`selectedIndex: $selectedIndex`
- 子组件可以修改值，父组件同步更新

#### @ObjectLink + @Observed
- 用于复杂对象的响应式更新
- 对象类需要使用 `@Observed` 装饰
- 组件使用 `@ObjectLink` 接收

**注意事项**：
- 万年历等复杂数据建议通过工具类获取，而非跨组件传递
- 大对象传递会影响性能，优先传递索引或ID

---

## 五、移植与复用指南

### 1. 项目内复用
在本项目的新页面中使用组件：

**步骤一：导入组件**
```typescript
import { DunjiaNineGrid } from '../components/DunjiaNineGrid'
import { DunjiaPalaceDetail } from '../components/DunjiaPalaceDetail'
import { DunjiaEngine, DunjiaPanResult } from '../utils/DunjiaEngine'
```

**步骤二：定义状态**
```typescript
@State panResult: DunjiaPanResult | null = null
@State selectedPalace: number | null = null
private engine: DunjiaEngine = DunjiaEngine.getInstance()
```

**步骤三：初始化与计算**
```typescript
aboutToAppear() {
  this.computePan()
}

private async computePan() {
  const input: DunjiaInput = {
    dateTime: new Date(),
    longitude: 116.4074,
    sceneType: DunjiaSceneType.GENERAL_STUDY
  }
  this.panResult = await this.engine.computePan(input)
}
```

**步骤四：在build中使用**
```typescript
build() {
  Column() {
    // 九宫格组件
    DunjiaNineGrid({
      panResult: this.panResult,
      selectedPalace: this.selectedPalace,
      onPalaceClick: (index) => {
        this.selectedPalace = index
      }
    })
    
    // 宫位详情组件
    DunjiaPalaceDetail({
      panResult: this.panResult,
      selectedPalace: this.selectedPalace
    })
  }
}
```

### 2. 项目间移植
将组件迁移到全新的 HarmonyOS 项目：

**UI组件迁移**：
1. 拷贝 `entry/src/main/ets/components/` 目录下的组件文件
2. 拷贝 `entry/src/main/ets/utils/DunjiaEngine.ets`（必须）
3. 确保目标项目已安装依赖：`@kit.AbilityKit`、`@kit.ArkTS`

**数据工具迁移**：
1. 拷贝 `entry/src/main/ets/utils/CalendarManager.ets`
2. **关键**：拷贝资源文件 `entry/src/main/resources/rawfile/calendar/` 目录下所有 JSON 文件
3. 拷贝 `entry/src/main/ets/utils/SolarTimeHelper.ets`（如需真太阳时功能）

**移植检查清单**：
- [ ] 组件文件已拷贝
- [ ] 工具类文件已拷贝
- [ ] rawfile资源文件已拷贝
- [ ] 路径引用已更新（相对路径）
- [ ] 依赖包已安装
- [ ] 初始化代码已添加

### 3. 注意事项

#### 路径一致性
- `CalendarManager` 内部硬编码了 `calendar/` 路径，确保 rawfile 目录结构一致
- 组件导入使用相对路径，注意目录层级

#### 单例状态
- 跨项目使用时，务必在入口处调用管理器的 `init()` 方法
- 否则 `context` 为空会导致读取文件失败

#### 类型定义
- 确保导出所有必需的 interface 和 enum
- 检查类型定义文件是否完整

#### 样式适配
- 组件内硬编码了部分颜色和尺寸
- 如需适配新项目的设计规范，建议提取为主题配置

---

## 六、最佳实践

### 1. 组件设计原则
- **单一职责**：一个组件只负责一个功能模块
- **纯展示**：UI组件不包含业务逻辑，只负责展示
- **明确接口**：通过 @Prop 和回调函数定义清晰的接口
- **避免副作用**：不要在组件内部修改外部状态

### 2. 性能优化
- **避免频繁重渲染**：合理使用 @State 和 @Prop
- **懒加载**：大数据集使用 LazyForEach
- **内存缓存**：频繁访问的数据使用 Map 缓存
- **异步加载**：文件读取使用 async/await

### 3. 错误处理
- **异常捕获**：所有异步操作使用 try-catch
- **降级方案**：数据加载失败时提供默认值
- **用户反馈**：加载状态、错误提示要清晰

### 4. 代码质量
- **类型安全**：禁用 any，启用严格类型检查
- **代码注释**：组件接口必须有 JSDoc 注释
- **命名规范**：组件名使用 PascalCase，方法名使用 camelCase
- **编译验证**：每次修改后必须编译通过才能提交
